
\chapter{Execution using a Stack Based Virtual Machine}

This chapter goes into detail about the method I used to execute the code generated by the code generator. The previous sections have mainly focused on compiling programs down to an instruction set. In this section I will go into detail about the design of that instruction set and the method I used to execute it.

When creating a compiler you must take in a source language, the code you wish to compile, and then output a target language. A target language is the language you wish to compile into. In simpler terms, your compiler is taking in programs in your source language and then outputting the same programs but they are now represented using your target language.    

For a project like this there are two approaches you can take when choosing what your target language should be. You can either find a preexisting low level language like ARM code or Java Byte Code. Or you can create your own instruction set and a virtual machine that is capable of executing those instructions. I decided to make my own instruction set and a virtual machine to execute it. 


\section{Introduction to Stack Based Virtual Machines}

There are two things too define here before we can start talking about stacked based virtual machines . We need to first define what is a virtual machine, then secondly what is a stack machine. 

A virtual machine can be described as a self contained operating environment that behaves as if it is a separate computer\footnotemark[1] . This can be useful because it means no matter what machine you are running your VM\footnotemark[2] on any application you run on your VM will run the same regardless of the physical machine you are using.

\footnotetext[1]{\url{http://www.webopedia.com/TERM/V/virtual_machine.html}}
\footnotetext[2]{VM is short hand for virtual machine}

A good example of a virtual machine is if you have ever played a retro games console emulators on your phone or computers. Those are examples of fully functional virtual machines running old programs independently of the machine they are running on. 

A stack machine is a machine or (virtual machine) that uses a pushdown stack instead of set registers to evaluate different expressions\footnotemark[3]. A pushdown stack is a data structure with two main operations;
%TODO reference intro to algo here % 

\begin{itemize}
\item Push, which puts something onto the stack.
\item Pop, which removes the last element put on to the stack.
\end{itemize} 

%Maybe chnage this analagy%
You can think of a stack like a PEZ sweet dispenser. The first bit of candy you put in goes straight to the bottom of your dispenser and if you put more in they get pilled in on top. This is the same way you push objects onto a stack. Then when you wish to eat your candy, the last piece you put in comes back out first. This is the equivalent of popping the stack where the last object you pushed onto the stack comes out first. This is called a last in first out system.    

\footnotetext[3]{\url{http://en.wikipedia.org/wiki/Stack_machine}}

Therefore a stack machine is quite simply a machine that uses a stack instead of allocated registers to handle expressions. If you look at %figure~\ref{fig:stackExample}% 
it shows you how the expression $2 - 1$ would be evaluated using a stack in a stack machine.

Now we understand what a stack machine is and what a virtual machine is it becomes quite easy to understand what a stack based virtual machine is. Quite simply it is a virtual machine that uses a stack architecture, effectively you can think of the virtual machine I created as a simple stack machine emulator. 


\section[Implementing a Stack Based Virtual Machine]{Implementing a Stack Based \\ Virtual Machine in Haskell}

The way the executor I crated works is it takes in code written from a simple instruction set then the virtual machine will execute the code one instruction at a time. For a quick overview of how my stack based virtual machine works you can look at the type of the main functions that handle executing code.

\begin{lstlisting}
	exec	:: Code -> String
\end{lstlisting}

Which simply starts a call to the recursive function;

\begin{lstlisting}
	exec' 	::exec' type goes here 
\end{lstlisting}

\newpage

What looking at $exec$ shows is all that is needed to start the executor is the code that has been generated by the code generator. Then looking at $exec'$ you can see the different data structures that are used in implementing my virtual machine in my executor. The main components are;

\begin{itemize}
\item The Code
\item The Program Counter
\item The Stack
\item Memory
\item Channels
\item List of Subroutines
\end{itemize}

The code is simply referring to the code you are currently executing and the program counter tells you where in that code you are. The stack is used like registers would be, where you will hold values you are currently interested in handling. Memory is where you store any variables that you will need to refer back to. Subroutines and channels are used for concurrency and I will go into more detail about them later. 

The key concept to take way is that memory is for storing objects for the long term where as the stack is for passing around values and holding them temporarily.

\subsection{Explanation of Instruction Set}

\begin{figure}[h]
\centering
\begin{lstlisting}

	data Inst  = PUSH Number
	              | PUSHV Name
	              | POP Name
	              | SHOW
	              | PRINT String  
      		      | DO ArthOp
       		      | COMP CompOp
       		      | JUMP Label
      		      | JUMPZ Label
      		      | LABEL Label
      		      | FUNC FName
      		      | FEND
      		      | VCALL Name
      		      | CALL Name
      		      | STOP
      		      | RSTOP
      		      | MAIN
      		      | PUSHC Name
      		      | POPC Name
      		      | CHANNEL Name
      		      | WAIT
      		      | KILL
      		      | GO Name 
	
	type Label =  Int


\end{lstlisting}
\caption{Haskell data structure used to represent all the instructions in my instruction set.}
\label{fig:instData} 
\end{figure}

Chapter 4 shows how the code is generated from an instruction set, and in figure~\ref{fig:instData} you can see the data structure I created in Haskell that represents my instruction set. 

To understand how this instruction set works it is good too look at a couple of examples of generated code from the instruction set and what exactly different instructions mean. Then we can move on to looking at more detailed example of how you go about building an executor for this instruction set in Haskell. 

If we first look at a variable assignment. If we wanted to compile the code: $x = 7;$ it becomes;

\begin{lstlisting}
	PUSH (Integer 7)
	POP "x"
\end{lstlisting}

Or more accurately in Haskell, since Code has the type $[Inst]$, it would look like this;

\begin{lstlisting}
	[PUSH (Integer 7), POP "x"]
\end{lstlisting}

This uses two of the most important instructions. $PUSH$ Takes a number as an argument and pushes it onto the stack, $POP$ takes a name as an argument and removes the head of the stack saving it in memory, overwriting any existing variables with the same name in the same scope in memory. You can use $PUSHV$ which takes a name as argument to push a variable from memory onto the stack. 

In code generation one of the few features of the instruction set I went into in any detail was the idea behind the $LABEL$ and $JUMP$ instructions. So you may remember that compiled code for the expression;

\begin{lstlisting}
	for (x < 5) {
		x++;
	};
\end{lstlisting}

Will look like this;

\begin{lstlisting}
	[LABEL 0, PUSHV "x", PUSH (Integer 5), COMP LET, 
	JUMPZ 1, PUSHV "x", PUSH (Integer 1), DO ADD, 
	JUMP 0, LABEL 1]			
\end{lstlisting}

To understand this better we can annotate the code to show what is going on at each instruction, this is shown in figure~\ref{fig:whileExp}. It is a good way to explain several instructions that I will be using frequently throughout this chapter.

\begin{figure}[h]
\centering
\begin{lstlisting}[basicstyle=\ttfamily\small]
LABEL 0	         -- places a label with name 0 

PUSHV "x"        -- pushes variable x onto the stack 

PUSH (Integer 5) -- pushes the number 5 onto the stack 

                    performs "<" comparison between the 
COMP LET         -- top 2 elements of the stack, places 0 
                    ontop of the stack if it's false and 
                    1 if true   
	                    
JUMPZ 1          -- jumps to label 1 if the head of the 
                    stack is 0 
	
PUSHV "x"        -- pushes varaible x onto the stack
	
PUSH (Integer 1) -- pushes number 1 onto the stack
	
DO ADD           -- adds the top two items on top of the
                    stack, places result on top of stack

POP "x"          -- pops the item from top of stack and
                    saves it memory with name "x"

JUMP 0           -- Jumps to the label 0         

LABEL 1          -- places label 1 			
\end{lstlisting}
\caption{Annotated example of what each instruction is doing in a simple while loop}
\label{fig:whileExp} 
\end{figure}

This gives a more detailed insight into how $JUMP$, $JUMPZ$ and $LABEL$ are used to represent conditional expressions on a lower level. It also introduces the idea of how you perform operations involving two values, where you have instructions that pop the top two elements of the stack then push the result of the operation back onto the stack.

\subsection{Example Code Execution}
\label{sec:exmpCodeExec}
I will now run through an example of how I created an executer for my instruction set. To do this i will start with a data structure representing an much smaller set of instrucions and then show how I build a virtual machine capable of executing code built from these instructions.

The instructions I will use in my example can be shown in the following data structure;

\begin{lstlisting}
	data Inst  = PUSH Number
	              | PUSHV Name
	              | POP Name
      		      | DO ArthOp
       		      | JUMP Label
      		      | JUMPZ Label
      		      | LABEL Label
\end{lstlisting} 

This is a relatively small set of instructions in comparison to what I used in my final project, but you should be familiar with most of the commands, as they were all introduced in the previous section. 

Now we have our instruction set we can move on to defining everything we will need to make it work.

\begin{lstlisting}
	type Name   = String
	
	type Number = Int
	
	type Label  = Int
	
	data ArthOp = ADD | SUB 
\end{lstlisting} 

Now we have some raw data types to use, we now need to think about what we will need in our virtual machine to make it work. For this example we will definitely need a memory and a stack. So we add;

\begin{lstlisting}
	type Code    = [Inst]
	
	type Stack   = [Number]
	
	type Memory  = [(Name, Number)]		
\end{lstlisting} 

It make sense that memory should be a list of tuples because memory is a series of values with an allocated name used to reference them. It also makes sense that our Stack just needs to be a list of numbers. We now need to decide what our executors type should be. I think its good if it takes in some code and returns us the stack. But the problem with that is how do we pass about all the components of our virtual machine. well we need too create a helper funstion thats going to do all the hard work. Seeing as we just need the code to start our executor we can write;

\begin{lstlisting}
exec     :: Code Stack
exec c   = exec' c 0 [] []

exec'    :: Code -> Int -> Stack -> Memory -> Stack	
\end{lstlisting} 

So now we need to decide how we will handle our code. If our code is just a list of instructions then we can use our program counter to find the element in the list we should be dealing with then use a case analysis to say what to do depending on our instruction.

Lets pretends we have already defined some functions to speed things up. 
\begin{itemize}
\item $pop$ will take in the stack and return the stack after popping it
\item $push$ will take in the stack and a value, pushing that value to the top of the stack, then returning the updated stack
\item $pushv$ will do the same as $push$ but takes in a name and memory and pushes the variable from memory to the stack
\item $save$ will take the head of the stack and a name, then save that value to memory
\item $jump$ will take in the code and a label number and return a program counter that is set to the location of that label.
\item $jumpz$ does the same as $jump$ but takes in the stack as well only performing a jump if the head of the stack is 0, otherwise it just increments the program counter as normal.
\end{itemize}

 
We will also need to define a function $do$ that will take take in the stack and an $ArthOp$. Then it will return the stack after performing the required operation on the top two elements of the stack and pushing the result on top. I will define this function below as an example, so as to give you an idea as to how some of the other functions could be implemented.

\begin{lstlisting}
  do      :: ArthOp -> Stack -> Stack
  do o s  = case o of
               ADD -> push (v2 + v1) ns 
               SUB -> push (v2 - v1) ns
            where 
               v1   = head s
               v2   = head (tail s)
               ns = (pop (pop s)) 
\end{lstlisting}

\newpage

Now that we have these functions we can easily create a recursive function to handle a long list of instructions. 

\begin{lstlisting}[basicstyle=\ttfamily\small]
exec'     :: Code -> Int -> Stack -> Memory -> Stack
exec'c pc s m 
          = if pc >= (length s) then s 
            else 
              case c !! pc of
                POP n    -> exec' c (pc+1) (pop s) (save s m)
                PUSH v   -> exec' c (pc+1) (push v s) m
                PUSHV n  -> exec' c (pc+1) (pushv n m s) m
                LABEL l  -> exec' c (pc+1) s m
                JUMP l   -> exec' c (jump l c) s m
                JUMPZ l  -> exec' c (jumpz l c s) (pop s) m
                DO o     -> exec' c (pc+1) (do o s) m               
\end{lstlisting}

The above function is a very basic example of how the main function in my executor works. Using recursion and pattern matching I am able to iterate over a list of instructions and create multiple functions to assist me in creating an efficient implementation of a virtual machine.  

\subsection{Analysis and Expansion of Code Execution Example}

\subsection{Memory Design and Implementation}

Memory is handled very simply in this project it has the same type it was given in the example in section \ref{sec:exmpCodeExec} and variables are referenced in almost exactly the same manner. The only major difference is that I included variable scope in my project and as such had to handle a number of different possible outcomes.

     

\subsubsection{Handling Variable Scope}

The main difference from the example is that memory in my executor is partitioned when it is initialized. My parser does not allow for variables the empty string as the name. Therefore to partition memory I initiate memory by creating a list of ten empty values , $("",0)$. Then all global memory is stored at the head of the list and local memory is stored at the tail, meaning memory is split in two. This makes it easy to handle scope because every time there is a change of scope, e.g. you begin to execute a function, you can simply drop everything after the list of empty variables as they will no longer be in scope.
  
This is a very simple approach to partitioning memory and one of the weaker aspects of this project. The current implementation does not facilitate the use of pointers, due to the complete dropping of the previous local memory  on a change of scope, but this would not be too difficult to update my executor to handle. Though it may require restructuring the way I currently handle memory.  


\subsection{Stack Management}

\subsubsection{Handling Function Calls}

\subsubsection{Handling Recursion}

\subsection{Implementing Concurrency}

\subsubsection{How Goal Handles Concurrency}

\subsubsection{How my Virtual Machine Handles Concurrency}



