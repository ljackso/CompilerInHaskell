
\chapter{Code Execution using a Stack Based Virtual Machine}

This chapter goes into detail about the method I used to execute the code generated by the code generator. The previous sections have mainly focused on compiling programs down to an instruction set. In this section I will go into detail about the design of that instruction set and the method I used to run it.

When creating a compiler you must take in a source language, the code you wish to compile, and then output a target language. A target language is the language you wish to compile into. In simpler terms, your compiler is taking in programs in your source language and then outputting the same programs but they are now represented using your target language.    

For a project like this there are two approaches you can take when choosing what your target language should be. You can either find a preexisting low level language like ARM code or Java Byte Code. Or you can create your own instruction set and a virtual machine that is capable of executing those instructions. I decided to make my own instruction set and a virtual machine to execute it. 


\section[Introduction to Stack Based Virtual Machines]{Introduction to \\ Stack Based Virtual Machines}

There are two things too define here before we can start talking about stacked based virtual machines . We need to first define what is a virtual machine, then secondly what is a stack machine. 

A virtual machine can be described as a self contained operating environment that behaves as if it is a separate computer\footnotemark[1] . This can be useful because it means no matter what machine you are running your VM\footnotemark[2] on any application you run on your VM will run the same regardless of the physical machine you are using.

\footnotetext[1]{\url{http://www.webopedia.com/TERM/V/virtual_machine.html}}
\footnotetext[2]{VM is short hand for virtual machine}

A good example of a virtual machine is if you have ever played a retro games console emulators on your phone or computers. Those are examples of fully functional virtual machines running old programs independently of the machine they are running on. 

A stack machine is a machine or (virtual machine) that uses a pushdown stack instead of set registers to evaluate different expressions\footnotemark[3]. A pushdown stack is a data structure with two main operations;
%TODO reference intro to algo here % 

\begin{itemize}
\item Push, which puts something onto the stack.
\item Pop, which removes the last element put on to the stack.
\end{itemize} 

%Maybe chnage this analagy%
You can think of a stack like a PEZ sweet dispenser. The first bit of candy you put in goes straight to the bottom of your dispenser and if you put more in they get pilled in on top. This is the same way you push objects onto a stack. Then when you wish to eat your candy, the last piece you put in comes back out first. This is the equivalent of popping the stack where the last object you pushed onto the stack comes out first. This is called a last in first out system.    

\footnotetext[3]{\url{http://en.wikipedia.org/wiki/Stack_machine}}

Therefore a stack machine is quite simply a machine that uses a stack instead of allocated registers to handle expressions. If you look at %figure~\ref{fig:stackExample}% 
it shows you how the expression $2 - 1$ would be evaluated using a stack in a stack machine.

Now we understand what a stack machine is and what a virtual machine is it becomes quite easy to understand what a stack based virtual machine is. Quite simply it is a virtual machine that uses a stack architecture, effectively you can think of the virtual machine I created as a simple stack machine emulator. 


\section[Implementing a Stack Based Virtual Machine]{Implementing a Stack Based \\ Virtual Machine in Haskell}

The way the executor I crated works is it takes in code written from a simple instruction set then the virtual machine will execute the code one instruction at a time. For a quick overview of how my stack based virtual machine works you can look at the type of the main functions that handle executing code.

\begin{lstlisting}
	exec	:: Code -> String
\end{lstlisting}

Which simply starts a call to the recursive function;

\begin{lstlisting}
	exec' 	::exec' type goes here 
\end{lstlisting}

\newpage

What looking at $exec$ shows is all that is needed to start the executor is the code that has been generated by the code generator. Then looking at $exec'$ you can see the different data structures that are used in implementing my virtual machine in my executor. The main components are;

\begin{itemize}
\item The Code
\item The Program Counter
\item The Stack
\item Memory
\item Channels
\item List of Subroutines
\end{itemize}

The code is simply referring to the code you are currently executing and the program counter tells you where in that code you are. The stack is used like registers would be, where you will hold values you are currently interested in handling. Memory is where you store any variables that you will need to refer back to. Subroutines and channels are used for concurrency and I will go into more detail about them later. 

The key concept to take way is that memory is for storing objects for the long term where as the stack is for passing around values and holding them temporarily.

\subsection{Explanation of Instruction Set}

\begin{figure}[h]
\centering
\begin{lstlisting}

	data Inst  = PUSH Number
	              | PUSHV Name
	              | POP Name
	              | SHOW
	              | PRINT String  
      		      | DO ArthOp
       		      | COMP CompOp
       		      | JUMP Label
      		      | JUMPZ Label
      		      | LABEL Label
      		      | FUNC FName
      		      | FEND
      		      | VCALL Name
      		      | CALL Name
      		      | STOP
      		      | RSTOP
      		      | MAIN
      		      | PUSHC Name
      		      | POPC Name
      		      | CHANNEL Name
      		      | WAIT
      		      | KILL
      		      | GO Name 
	
	type Label =  Int


\end{lstlisting}
\caption{Haskell data structure used to represent all the instructions in my instruction set.}
\label{fig:instData} 
\end{figure}

Chapter 4 shows how the code is generated from an instruction set, and in figure~\ref{fig:instData} you can see the data structure I created in Haskell that represents my instruction set. 

To understand how this instruction set works it is good too look at a couple of examples of generated code from the instruction set and what exactly different instructions mean. Then we can move on to looking at more detailed example of how you go about building an executor for this instruction set in Haskell. 

If we first look at a variable assignment. If we wanted to compile the code: $x = 7;$ it becomes;

\begin{lstlisting}
	PUSH (Integer 7)
	POP "x"
\end{lstlisting}

Or more accurately in Haskell, since Code has the type $[Inst]$, it would look like this;

\begin{lstlisting}
	[PUSH (Integer 7), POP "x"]
\end{lstlisting}

This uses two of the most important instructions. $PUSH$ Takes a number as an argument and pushes it onto the stack, $POP$ takes a name as an argument and removes the head of the stack saving it in memory, overwriting any existing variables with the same name in the same scope in memory. You can use $PUSHV$ which takes a name as argument to push a variable from memory onto the stack. 

In code generation one of the few features of the instruction set I went into in any detail was the idea behind the $LABEL$ and $JUMP$ instructions. So you may remember that compiled code for the expression;

\begin{lstlisting}
	for (x < 5) {
		x++;
	};
\end{lstlisting}

Will look like this;

\begin{lstlisting}
	[LABEL 0, PUSHV "x", PUSH (Integer 5), COMP LET, 
	JUMPZ 1, PUSHV "x", PUSH (Integer 1), DO ADD, 
	JUMP 0, LABEL 1]			
\end{lstlisting}

To understand this better we can annotate the code to show what is going on at each instruction, this is shown in figure~\ref{fig:whileExp}. It is a good way to explain several instructions that I will be using frequently throughout this chapter.

\begin{figure}[h]
\centering
\begin{lstlisting}[basicstyle=\ttfamily\small]
LABEL 0	         -- places a label with name 0 

PUSHV "x"        -- pushes variable x onto the stack 

PUSH (Integer 5) -- pushes the number 5 onto the stack 

                    performs "<" comparison between the 
COMP LET         -- top 2 elements of the stack, places 0 
                    ontop of the stack if it's false and 
                    1 if true   
	                    
JUMPZ 1          -- jumps to label 1 if the head of the 
                    stack is 0 
	
PUSHV "x"        -- pushes varaible x onto the stack
	
PUSH (Integer 1) -- pushes number 1 onto the stack
	
DO ADD           -- adds the top two items on top of the
                    stack, places result on top of stack

POP "x"          -- pops the item from top of stack and
                    saves it memory with name "x"

JUMP 0           -- Jumps to the label 0         

LABEL 1          -- places label 1 			
\end{lstlisting}
\caption{Annotated example of what each instruction is doing in a simple while loop}
\label{fig:whileExp} 
\end{figure}

This gives a more detailed insight into how $JUMP$, $JUMPZ$ and $LABEL$ are used to represent conditional expressions on a lower level. It also introduces the idea of how you perform operations involving two values, where you have instructions that pop the top two elements of the stack then push the result of the operation back onto the stack.

\subsection{Example Virtual Machine}
\label{sec:exmpCodeExec}
I will now run through an example of how I created a virtual machine to handle my instruction set. To do this I will start with a data structure representing a much smaller set of instructions and then show how I build a virtual machine capable of executing code built from these instructions.

The instructions I will use in my example can be shown in the following data structure;

\begin{lstlisting}
	data Inst  = PUSH Number
	              | PUSHV Name
	              | POP Name
      		      | DO ArthOp
       		      | JUMP Label
      		      | JUMPZ Label
      		      | LABEL Label
\end{lstlisting} 

This is a relatively small set of instructions in comparison to what I used in my final project, but you should be familiar with most of the commands, as they were all introduced in the previous section. 

Now we have our instruction set we can move on to defining everything we will need to make it work.

\begin{lstlisting}
	type Name   = String
	
	type Number = Int
	
	type Label  = Int
	
	data ArthOp = ADD | SUB 
\end{lstlisting} 

Now we have some raw data types to use, we now need to think about what we will need in our virtual machine to make it work. For this example we will definitely need a memory and a stack. So we add;

\begin{lstlisting}
	type Code    = [Inst]
	
	type Stack   = [Number]
	
	type Memory  = [(Name, Number)]		
\end{lstlisting} 

It make sense that memory should be a list of tuples because memory is a series of values with an allocated name used to reference them. It also makes sense that our Stack just needs to be a list of numbers. We now need to decide what our executors type should be. I think its good if it takes in some code and returns us the stack. But the problem with that is how do we pass about all the components of our virtual machine. well we need too create a helper function thats going to do all the hard work. Seeing as we just need the code to start our executor we can write;

\begin{lstlisting}
exec     :: Code Stack
exec c   = exec' c 0 [] []

exec'    :: Code -> Int -> Stack -> Memory -> Stack	
\end{lstlisting} 

So now we need to decide how we will handle our code. If our code is just a list of instructions then we can use our program counter to find the element in the list we should be dealing with then use a case analysis to say what to do depending on our instruction.

Lets pretends we have already defined some functions to speed things up. 
\begin{itemize}
\item $pop$ will take in the stack and return the stack after popping it
\item $push$ will take in the stack and a value, pushing that value to the top of the stack, then returning the updated stack
\item $pushv$ will do the same as $push$ but takes in a name and memory and pushes the variable from memory to the stack
\item $save$ will take the head of the stack and a name, then save that value to memory
\item $jump$ will take in the code and a label number and return a program counter that is set to the location of that label.
\item $jumpz$ does the same as $jump$ but takes in the stack as well only performing a jump if the head of the stack is 0, otherwise it just increments the program counter as normal.
\end{itemize}

 
We will also need to define a function $do$ that will take take in the stack and an $ArthOp$. Then it will return the stack after performing the required operation on the top two elements of the stack and pushing the result on top. I will define this function below as an example, so as to give you an idea as to how some of the other functions could be implemented.

\begin{lstlisting}
  do      :: ArthOp -> Stack -> Stack
  do o s  = case o of
               ADD -> push (v2 + v1) ns 
               SUB -> push (v2 - v1) ns
            where 
               v1   = head s
               v2   = head (tail s)
               ns   = (pop (pop s)) 
\end{lstlisting}

\newpage

Now that we have these functions we can easily create a recursive function to handle a long list of instructions. 

\begin{lstlisting}[basicstyle=\ttfamily\small]
exec'     :: Code -> Int -> Stack -> Memory -> Stack
exec'c pc s m 
          = if pc >= (length s) then s 
            else 
              case c !! pc of
                POP n    -> exec' c (pc+1) (pop s) (save s m)
                PUSH v   -> exec' c (pc+1) (push v s) m
                PUSHV n  -> exec' c (pc+1) (pushv n m s) m
                LABEL l  -> exec' c (pc+1) s m
                JUMP l   -> exec' c (jump l c) s m
                JUMPZ l  -> exec' c (jumpz l c s) (pop s) m
                DO o     -> exec' c (pc+1) (do o s) m               
\end{lstlisting}

The above function is a very basic example of how the main function in my executor works. Using recursion and pattern matching I am able to iterate over a list of instructions and create multiple functions to assist me in creating an efficient implementation of a virtual machine.  

\section{Handling More Advanced Features}

After using the example to show you how my executor works, I will now discuss some of the more interesting features I implemented in my executor and how I handled these features. 

\subsection{Memory Design and Implementation}

Memory is handled very simply in this project it has the same type it was given in the example in section \ref{sec:exmpCodeExec} and variables are referenced in almost exactly the same manner. The only major difference is that I included variable scope in my project and as such had to handle a number of different possible outcomes.

\subsubsection{Handling Variable Scope}

The main difference from the example is that memory in my executor is partitioned when it is initialized. My parser does not allow for variables the empty string as the name. Therefore to partition memory I initiate memory by creating a list of ten empty values , $("",0)$. Then all global memory is stored at the head of the list and local memory is stored at the tail, meaning memory is split in two. This makes it easy to handle scope because every time there is a change of scope, e.g. you begin to execute a function, you can simply drop everything after the list of empty variables as they will no longer be in scope.
  
This is a very simple approach to partitioning memory and one of the weaker aspects of this project. The current implementation does not facilitate the use of pointers, due to the complete dropping of the previous local memory  on a change of scope, but this would not be too difficult to update my executor to handle. Though it may require restructuring the way I currently handle memory.  


\subsection{Stack Management}

Manging a stack is a very important part of implementing an efficient and, more importantly, working stack based virtual machine. 

\subsubsection{Handling Function Calls}

Handling function calls is one of the more interesting things to implement in a stack. If we first look at what happens in our executor when we hit the two commands that deal with function calls; either $VCALL$ (for void function calls) or $CALL$, a function called $handleCall$  is called. The purpose of this function is to execute the function call before moving onto the next command. This seems simple enough but there are two complications; functions that take in arguments and functions that return values.

If we first look at handling arguments, one approach could be to change the data type of the function call instructions to now incorporate arguments is as well like this;

\begin{lstlisting}
	data Inst     = ...
	                |CALL Name [Argument]
	                |VCALL Name [Argument]
	                ...
				
	type Argument = Number
\end{lstlisting}        

This looks like a good solution at first,  but what if we want to call a function using an expression or a variable as arguments. Calls like $fun(a+5,(4*b)-c);$ would start to get very messy to deal with. 

A better approach would be to use stack frames. A stack frame is a frame of data that is put on top of the stack. In the case of function calls it means putting all the arguments onto a the stack, then ensuring they are popped off in the correct order.   
%TODO Find better reference than stack overflow %

If we look at what happens if we were to call a function that takes in 2 arguments we can see that both arguments get pushed onto the stack before calling the function, this is shown below.

\begin{lstlisting}
	fun(12, 30); 	-->  PUSH (Integer 30)
	                     PUSH (Integer 12)
        	             CALL "fun"	
\end{lstlisting}

Now to understand what happens in $handleCall$ we must look at what the function does. In simple terms it calls $funExec'$, a function which behaves almost exactly as our main executor except with some limits to what can be done inside a function (mainly to do with concurrent processes), and then moves onto the next instruction by updating the program counter and calling $exec'$ after updating the stack and memory. 

Lets look at the code to be executed now in $funExec$ if we see that function $fun$ looks like this;

\begin{lstlisting}
	func fun(a int, b int){
		...
	};
\end{lstlisting}

So the way in which the arguments would be passed is to pass the stack into $funExec'$ then pop of the items in the correct order. This can be show here;

\begin{lstlisting}
  -main executor;           -function executor;
  ...
  PUSH (Integer 30)
  PUSH (Integer 12)
  CALL "fun"
             -- pass stack --> 
                            FUNC "fun  
                            POP "a"
                            POP "b"
                            ...
\end{lstlisting}
  
Now all your arguments are set up in memory to use within the function. It is important to note that when calling functions rather than just insert the function code into the current executing code I actually cause a new instance of an executor to run and passed around the stack and correct memory scopes. 

This was a design choice as I felt that this approach gave me more control as to how I wanted to implement recursion and how I wanted functions to behave in general. I also felt it was a cleaner approach that more closely mirrored how I wanted functions to be treated.

Dealing with  functions that return values is very similar to how we handled arguments, just the other way round. If we look at an assignment;

\begin{lstlisting}
	j = 13;  --> PUSH (Integer 13)
	             POP "j"	
\end{lstlisting}

You can see that when dealing with an assignment you are popping the top of the stack. Therefore if our assignment looked like this;

\begin{lstlisting}
	j = gun();
\end{lstlisting} 

We must ensure that the value our function $gun()$ returns is left on top of the stack to be popped of our assignment. The instruction $RSTOP$ is used to signify a return value and will break out of $funExec'$. Therefore if we combine both our previous examples we can show how a function which takes in arguments will be called and how the stack is updated and passed around.

Lets look at the function;

\begin{lstlisting}
	func fun(a int, b int){
		Return a + b;
	};
\end{lstlisting}

Then how it would behave if we use it as part of assignment;

\begin{lstlisting}
	j = fun(5, 8);
\end{lstlisting}

Looking at figure~\ref{fig:stackFrame} we can see how this simple command is dealt with by the executor and the function executor functions. 

\begin{figure}[h]]
\centering
\begin{lstlisting}
  -main executor;           -function executor;
  ...
  PUSH (Integer 30)
  PUSH (Integer 12)
  CALL "fun"
             -- pass stack --> 
                            FUNC "fun  
                            POP "a"
                            POP "b"
                            PUSHV "a"
                            PUSHCV "b"
                            DO ADD
                            RSTOP
             <-- pass stack --
 POP "j"                               
\end{lstlisting}
\caption{Example of how functions are called, including passing arguments and returning a value}
\label{fig:stackFrame}
\end{figure}

This examples shows how stack frames are used to handle passing arguments and the returning of values in functions in my virtual machine.

\subsubsection{Handling Recursion}

Another interesting feature to implement in a stack based virtual machine is allowing function recursion. Function recursion is when you allow a function to call itself inside it's function definition. An example of this can be seen below in figure~\ref{fig:facExamp} function that will give you the factorial of the number  

\begin{figure}
\begin{lstlisting}
	func fac(n int) int {
	    if (n == 0) {
	        return 1;
	    }; 
	    return n * fac(n-1);
	};
\end{lstlisting}
\caption{Example of a recursive function $fac$, and example of how it works }
\label{fig:facExamp}
\end{figure}

This not only gives an example of how a recursive function can work, but also helps to show what a powerful tool recursion can be in solving different sorts fo problems. 

To implement recursion I simply had to ensure that each stack frame generated for each new function was properly created and passed on. There was no special trick to allowing recursion other than ensuring my initial implementation of calling functions worked as intended then it was simply a question of allowing the function executor to be allowed to handle call function calls which would run a new instance of the function executor at the call step, ensuring the correct stack was passed and returned from $funExec'$. 

\subsection{Implementing Concurrency}

\subsubsection{How Goal Handles Concurrency}

This section is a brief recap of what was explained in section \ref{sec:concDes} where we talked about how Goal was designed to handle concurrency. There are three important features of Goal that needed to be implemented and handled by my compiler and executor;

\begin{itemize}
\item $go$ keyword, using this command with a void function starts a new instance of that method as a concurrent process, know as a sub routine.
\item $Kill()$ command, this stops all concurrent processes 
\item $Wait()$ command, this will cause a program to wait at this point until all sub routines have stopped running.
\end{itemize}

There are also channels which are used to pass information between subroutines, these are described in greater detail in section \ref{sec:concDes} and in the Goal documentation.   

\subsubsection{How my Virtual Machine Handles Concurrency}

Handling the creation and running of concurrent processes is definitely one of the more exciting features of my project. To understand how my executor deals with concurrency it is good to look at the type of my main executor function;

%TODO make this look pretty %
\begin{lstlisting}[basicstyle=\ttfamily\tiny]
exec' :: Code ->  Int -> Stack -> Mem -> Bool -> [Channel] -> (Seq GoRoutine, Int) ->  EndParam
\end{lstlisting}

The bits we are interested in for handling concurrency are the types;

\begin{itemize}
\item $[Channel]$
\item $(Seq$ $GoRoutine,$ $Int)$  %This could become ST (Seq GoRoutine) %
\item $EndParam$
\end{itemize} 

These are types represent the way in which I pass around subroutines and channels in my executor. 

If we first talk about how I handle channels we can then discuss subroutines in more detail . Channels are not held in memory but instead are stored independently. There are three instructions that can effect channels;

\begin{itemize}
\item $CHANNEL n$, which creates a new channel
\item $PUSHC n$, which takes whats on the top of the stack and pushes into onto the correct channel 
\item $POPC n$, which pops the correct channel and pushes the popped item onto the stack
\end{itemize} 

These instructions can not only be executed by the main executor but also be executed within functions. Therefore it is important to look at our type $EndParam$ which our function executor will return;

\begin{lstlisting}
EndParam  = ((Stack, Mem), ([Channel], (S.Seq GoRoutine, Int))) 
\end{lstlisting}

You can see that $EndParam$ returns all the data structures used within my virtual machine, most importantly you can see that it returns a list of channels. Showing you can be updating your channels within functions and once that function has been executed it will return the $EndParam$  which will update the channels you have used in your functions.

Thus meaning code such as;

%TODO test this code... %
\begin{lstlisting}
	func main() {
		var c chan = Make(chan int);
		funA();
		j = <- c;
		Show(j);
	};
	
	func funA() {
		c <- 1;
		c <- 2;
		funcB();
	};
	
	func funC() {
		c <- 3;
	};

	OUTPUTS : 3
	          D0NE
\end{lstlisting}

Is perfectly valid due to the nature of how I execute functions and the data structure used to store and pass channel data. 

Channels are regulated by a series of functions that are called each time a channel operation is performed. For example there are functions that check that you are not creating a new channel with the same name as a pre-existing channel and functions that check you are not trying to push and pop to a non existent channel.

We will now start talking about how sub routines are created and handled.

When a sub routine is created it's information is represented by the data type $GoRoutine$. This is a data structure that holds everything that a sub routine needs to run as independent process (excluding channel data). This structure is show below;

\begin{lstlisting}
	data GoRoutine   = Go Code Int Stack Mem  
\end{lstlisting}   

This gives every subroutine;

\begin{itemize}
\item Code to execute
\item A program counter
\item An independent stack
\item A local memory
\end{itemize}
 

To handle multiple subroutines they are handled by the type $(Seq$ $GoRoutine,$ $Int)$. The $Seq$ monad is used to handle a list of items, I felt it was safer to use in order to maintain the order of items. 

Now we know what format our subroutines will be passed round our executor we now need a way of executing them concurrently. Here it is important that to realize we are not creating truly concurrent processes in the sense that they run at exactly the same time. Instead what we are doing is interweaving the execution of processes to create the illusion of them executing in parallel. 

To do this at each step of our executor we call the function $subRoutsHandler$. This will execute ten commands of on of our subroutines for every one command executed by out main executor. 

You may have noticed that our subroutines are passed around in a tuple with an integer. This integer is used to keep track of which process is currently being executed. 

To better understand what is going on we should look at how the $WAIT$ and $KILL$ commands are handled by the main executor, $exec'$;

\begin{lstlisting}
...
KILL -> exec' c (pc+1) s m g ncs (S.fromList [], 0)
WAIT -> if (S.null gs) then
           exec' c (pc+1) s m g ncs (S.fromList [], 0)      
        else 
           exec' c pc s m g ncs (ngs, ngc)   
...
  where
     con     = subRoutsHandler gs gc cs
     ncs     = snd con
     ngs     = fst (fst con)
     ngc     = snd (fst con)
\end{lstlisting}    
 

You can see here how $subRoutsHandler$ will be called and how the different values it needs to return are placed back into the virtual machine. 

This code also show how $KILL$ simply removes all running subroutines and $WAIT$ stops until there are no more processes left to run, as every time a subroutine is finished running it is removed from the list.

To summarize a sequence of subroutines are handled by a separate executor at each step in my executor, this separate executor executes several commands before returning the updated information of the subroutines. The current subroutine being executed is kept track of using a counter. 


