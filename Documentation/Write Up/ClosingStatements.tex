
\chapter{Closing Statements}

\section{Conclusion}

In conclusion during the course of writing this dissertation I achieved what I set out to do. I created a compiler that can handle a concurrent programming language. On top of that I also manged to create my own programing language and a virtual machine to run it. 

With regards to the language I created I feel that it accurately portrays it's inspiration from Go whilst at the same time having a lot of individuality. I feel the way I designed Goal to handle concurrency not only makes it easy to use but useful for the creation of concurrent programs. I also think that Goal can ended up having some practical uses, especially as a tool for teaching concurrency due to its easy to understand syntax and how simple it is to implement concurrent programs.

In terms of the dissertation write up I felt that overall this project can be used for people in the future who are interested in implementing there own compiler in Haskell. This document strives to serve as a tool people can use in  the future to learn more about implementing compilers and virtual machines in Haskell.

This project was never setting out to be ground breaking, but I aimed to create something that could be used to help people in the future. Primarily by writing a document that provided people with an insight into how to go about creating the different aspects of a compiler and virtual machine in Haskell, and to highlight some off the different approaches available to someone tackling this sort of problem in the future.

This project started as a means for me to learn more about compilers, language design and Haskell. In the end I felt not only did learn about these topics but also created something that could help others to learn about the same things I ended up learning about. 

I hope that Goal goes on to find some use in the future either as a teaching tool or as a future project for someone to expand on. I also hope that this document helps other  people answer the sort of questions I had at the start of this project. 

\section{Reflection}

The initial aim of this project was to create a compiler in Haskell for a concurrent programming language. Over time the project has expanded to include creating an executor and even designing my own language to compile. Although there were changes to the process, I still managed to achieve the primary goal of implementing a concurrent compiler.

There were several advanced features in my compiler implementation but on reflection I would say the project can be boiled down to a few interesting aspects;

\begin{itemize}
\item The design and creation of a new concurrent programing language, Goal.
\item Parsing using monadic parser combinators.
\item Allowing function recursion. 
\item Allowing the running of concurrent processes within my compiler.
\end{itemize}

There are many aspects of this project that I am proud of, but being able to implement concurrency is obviously the highlight. 

Although this project was a success I would argue there are several areas for expansion or possible improvements, as with most programming languages. Throughout this write up I have touched on several aspects that could be expanded and I feel on reflection three main features would be the first to be added; 

\begin{itemize}
\item Expanding the type system
\item Allowing arrays 
\item Pointers
\end{itemize}    

Adding types, as was discussed, came down to an issue with parsing and deciding that other features where more important, even though my executor is set up to handle extra numerical types, I decided not to ship something half done.

With pointers and arrays these were two features that interested me but I felt again I was more interested in focusing my efforts elsewhere. Even though these feature could be areas to expand the project I do not feel without these features Goal is any less useful. As there are still work rounds.

In reflection I feel this project was very successful not just in what I initially set out to achieve in creating a concurrent compiler, but also it succeeded in creating a new programing language, Goal, and an executor to run it. 

Importantly I feel although this project is complete it has been created in such a way that if someone was interested in expanding Goal it would only take an understanding of Haskell and Monads and a bit of enthusiasm, to start adding new features. Which is something I'm glad I achieved. 

Overall I am very pleased with the compiler I created. I feel the language I initially created as a tool to explore compiler design and concurrency has, due to the completeness of my compiler implementation, changed from a simple experiment to a complete language with it's own uses. Which is a very good side effect of a what started as a simple exploration into creating compilers in Haskell. 
